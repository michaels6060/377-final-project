# CS377 Final Project: Rust Implementation of Scheduling Algorithms, with MLFQ

By Michael Sun \
Due May 17 2023

---

## How to Run

To run my project, the first step is to install Rust. Details are here: <https://www.rust-lang.org/tools/install>

After installing, in the terminal, from the *final_scheduler* directory, type "cargo run -- [algorithm] [workload file]". Input for the algorithm is expected to be one of [fifo|sjf|stcf|rr|mlfq], specifically in lowercase. Workload files are located in the *workloads* folder. You can make more workload files, just as long as they follow the convention of the workload files that were given for project 3, a line represents a process and contains 2 integers (this is important, I have not thoroughly tested nor do I believe my code will work correctly if given floats). The first integer represents the start time, the second reperesents the duration.

Alternatively, because the code has already been built and compiled before, you could alternatively run "./target/debug/final_scheduler [algorithm] [workload file]". This directly runs the machine code. Cargo builds and compiles project to this file by default.

## Design

### Cargo

This project was built using Cargo. Cargo essentially is a package managment and build tool for Rust projects. The structure of a Cargo project is there is essentially a *Cargo.toml* file and a *Cargo.lock* file. *Cargo.toml* is maintained by the author and basically lists the dependencies the project has on external packages, or "crates" as is commonly used by people who use Rust. *Cargo.lock* stores information regarding version information of those crates and is generated by Cargo and not meant to be edited manually. From here, you can run Cargo commands that are able to build you project, mostly importantly using the **rustc** compiler to run your code.

### Code Structure

My code structure is split into 2 files in *src*, *main.rs* and *scheduler.rs*. *main.rs* is the driver code, and is what the file **rustc** targets to run. *scheduler.rs* contains the code for all the actual thing related to the scheduling and process simulator, the functionalities to print, the algorithms themselves, etc. It can be thought of as a C++ header file.

As a slight detour to explain this more, when you compile in C or C++, you usually have your source files and then header files. When you edit your source file, you only have to recompile that source file and then relink the header files. Rust does not use header files and the linking process is taken care of by **rustc**. At the very top of *main.rs* when I call "mod scheduler" and  "use scheduler::*" I am directly using the code as a package much like in Python without the need of a header file.

If you are familiar with Rust, you might ask why I don't have a *lib.rs* file or separate my code into modules. The answer is that I am still learning Rust and still find the idiomatic project structure to still be slightly confusing. Additionally, I also thought that my code was simple enough to where extracting out modules was not necessary.

### main.rs

*main.rs* is a simple program that processes command line arguments given when the program is run. It expects 3, the file itself, the algorithm, and the workload file. From there, following a similar structure to project 3, it reads the file, and generates the workload. Then it goes through a "match" statement which is the same as a switch statement. It runs "show_metrics" on the return of running the given algorithm on the workload, which will print out the statistics and the processes themselves, all with similar behavior to project 3.

### scheduler.rs

The way *scheduler.rs* is structured is mainly in 3 parts, the struct defintion of a process, utility functions such as getting average turnaround time or printing, and the scheduling algorithms themselves.

In terms of design choice, I mostly followed my code for project 3 as to still have something to compare my code to so I could ensure that my code was correct.

The Process struct has an added "remaining_time" field to make it easier conceptualize a time slice or quantum specifically for usage in the round robin and MLFQ algorithm. They are floats because I wanted to test float time quantums.

As another aside to explain a core feature of Rust, you might notice that all the inputs to my functions take what seems to be an a pointer. This is actually a process called borrowing in Rust. At any time, a piece of data in the heap, which we have learned is alloacted and is variable size, can only have one fixed size pointer on the stack that points to it, or as it is called in Rust, "owns" it. This system of owernship adds a lot of safety and reduces the need for direct manual memory management.

In terms of design choice for algorithm design, I utilized an external crate called binary-heap-plus which is a crate that adds extra functionality to the binary-heap struct in the standard library. This is a common practice in Rust, the standard library is relatively smaller and using crate depdendencies is common. The actual functionality it provides is that it allows you to pass in a custom comparator for the heap. I intially tried to implement my own heap structure but I found it to be more challenging and used this crate instead.

More detailed descriptions directly about functionality are in comments in the code.

### MLFQ

Aside from reimplenting project 3 to learn Rust and explore how Rust functions as a systems programming language, I also decided to try to implement an MLFQ to simulate another scheduling algorithm. When running my code using the mlfq command, it will print out the current MLFQ status as well to specifically illustrate how my implementation actually works with changing the prioritiy levels. Priting is enabled by default. To disable, there is a constant at the top of *scheduler.rs* that needs to be manually changed to false. There is also a constant for boost time, change this to change how often the MLFQ will do a boost of all processes. From my initial observations, turnaround times is reduced if you have more longer or intensive processes if you decrease turnaround time, but you get more starvation if you have a lot of shorter processes with a few longer, more intensive processes and a longer boost time.
